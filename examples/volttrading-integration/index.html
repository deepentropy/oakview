<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OakView + VoltTrading Integration</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #131722;
      color: #d1d4dc;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      height: 100vh;
      overflow: hidden;
    }

    oakview-chart-layout {
      width: 100%;
      height: 100vh;
    }
  </style>
</head>
<body>
  <oak-view id="chart" layout="single" symbol="AAPL" theme="dark"></oak-view>

  <script type="module">
    /**
     * VoltTrading Integration Example
     *
     * This demonstrates how to use OakView with a custom data provider.
     */

    // Import OakView layout component
    import '../../dist/oakview.es.js';

    // Import custom VoltTrading provider
    import VoltTradingProvider from './volttrading-provider.js';

    // Simple WebSocket wrapper
    class SimpleWebSocket {
      constructor() {
        this.ws = null;
        this.listeners = new Map();
      }

      connect() {
        this.ws = new WebSocket('ws://localhost:8000/ws');

        this.ws.onopen = () => {
          console.log('Connected to VoltTrading backend');
          this.emit('connected', {});
        };

        this.ws.onmessage = (event) => {
          const message = JSON.parse(event.data);
          this.emit(message.type, message.data);
        };

        this.ws.onclose = () => {
          console.log('Disconnected from VoltTrading backend');
          this.emit('disconnected', {});
        };
      }

      on(event, callback) {
        if (!this.listeners.has(event)) {
          this.listeners.set(event, []);
        }
        this.listeners.get(event).push(callback);
        return () => {
          const listeners = this.listeners.get(event);
          if (listeners) {
            const index = listeners.indexOf(callback);
            if (index > -1) listeners.splice(index, 1);
          }
        };
      }

      emit(event, data) {
        const listeners = this.listeners.get(event);
        if (listeners) {
          listeners.forEach(callback => callback(data));
        }
      }

      isConnected() {
        return this.ws && this.ws.readyState === WebSocket.OPEN;
      }

      close() {
        if (this.ws) this.ws.close();
      }
    }

    // Simple API wrapper
    class SimpleAPI {
      constructor() {
        this.baseUrl = 'http://localhost:8000';
      }

      async getHistoricalData(symbol, duration, timeframe) {
        const url = `${this.baseUrl}/api/market-data/${symbol}/history?timeframe=${timeframe}&duration=${encodeURIComponent(duration)}`;
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        return await response.json();
      }

      async subscribeMarketData(symbols) {
        const url = `${this.baseUrl}/api/market-data/subscribe`;
        const response = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(symbols)
        });
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        return await response.json();
      }

      async unsubscribeMarketData(symbols) {
        const url = `${this.baseUrl}/api/market-data/unsubscribe`;
        const response = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(symbols)
        });
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        return await response.json();
      }

      async searchSymbols(query) {
        const url = `${this.baseUrl}/api/symbols/search?q=${encodeURIComponent(query)}`;
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        return await response.json();
      }
    }

    // Per-pane subscriptions: paneId -> { unsubscribe, symbol, interval }
    const paneSubscriptions = new Map();

    // Track if config was restored to avoid duplicate loading
    let configWasRestored = false;

    // Set up config restoration listener BEFORE init
    // This must be done before the component connects to catch the config-restored event
    const chartLayout = document.getElementById('chart');

    chartLayout.addEventListener('config-restored', async (e) => {
      console.log('Configuration restored:', e.detail);
      configWasRestored = true;

      // Wait for provider to be initialized
      while (!window.voltProvider) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }

      const provider = window.voltProvider;

      // Load data for each pane with restored settings
      await loadAllPanes(provider, chartLayout);

      // Restore indicators for each pane
      console.log('Starting indicator restoration loop...');
      for (const paneConfig of e.detail.panes) {
        console.log(`Checking pane ${paneConfig.id}, indicators:`, paneConfig.indicators);
        if (paneConfig.indicators && paneConfig.indicators.length > 0) {
          console.log(`Restoring ${paneConfig.indicators.length} indicators for pane ${paneConfig.id}`);
          // Wait for data to be loaded first
          await new Promise(resolve => setTimeout(resolve, 500));

          // Find the pane index from the id
          const paneIndex = chartLayout._panes?.findIndex(p => p.id === paneConfig.id);
          if (paneIndex >= 0) {
            const chart = chartLayout.getChartAt(paneIndex);
            if (chart) {
              // Query indicator info from the indicator list DOM elements
              for (const indicatorId of paneConfig.indicators) {
                const indicatorItem = chart.shadowRoot?.querySelector(`.indicator-list-item[data-indicator-id="${indicatorId}"]`);
                if (indicatorItem) {
                  const indicatorModule = indicatorItem.getAttribute('data-indicator-module');
                  const calculationModule = indicatorItem.getAttribute('data-indicator-calc');

                  console.log(`Loading indicator: ${indicatorId}`);
                  await chart.loadIndicatorOnChart(indicatorId, indicatorModule, calculationModule);
                } else {
                  console.warn(`Indicator ${indicatorId} not found in indicator list`);
                }
              }
            }
          }
        }
      }
    });

    // Initialize
    async function init() {
      try {
        console.log('Initializing VoltTrading connection...');

        const wsService = new SimpleWebSocket();
        const apiService = new SimpleAPI();
        const provider = new VoltTradingProvider({ wsService, apiService });

        await provider.initialize();
        console.log('Provider initialized ✓');

        // Store provider globally so config-restored handler can access it
        window.voltProvider = provider;

        chartLayout.setDataProvider(provider);
        console.log('Data provider configured ✓');

        // Set up event listeners BEFORE loading data to catch any changes
        // Listen for interval changes (per-pane)
        chartLayout.addEventListener('interval-change', async (e) => {
          const { interval, paneIndex, paneId, symbol } = e.detail;
          if (paneIndex === undefined || paneId === undefined) {
            console.warn('interval-change event missing paneIndex or paneId');
            return;
          }
          // Get current chart type for this pane
          const chart = chartLayout.getChartAt(paneIndex);
          const chartType = chart?._currentChartType || 'candlestick';
          console.log(`Interval changed to ${interval} for pane ${paneIndex} (${symbol})`);
          await loadPane(paneIndex, paneId, symbol, interval, chartType, provider, chartLayout);
        });

        // Listen for symbol changes (per-pane)
        chartLayout.addEventListener('symbol-change', async (e) => {
          const { symbol, paneIndex, paneId } = e.detail;
          if (paneIndex === undefined || paneId === undefined) {
            console.warn('symbol-change event missing paneIndex or paneId');
            return;
          }
          // Get current interval and chart type for this pane
          const sub = paneSubscriptions.get(paneId);
          const interval = sub?.interval || '1D';
          const chart = chartLayout.getChartAt(paneIndex);
          const chartType = chart?._currentChartType || 'candlestick';
          console.log(`Symbol changed to ${symbol} for pane ${paneIndex}`);
          await loadPane(paneIndex, paneId, symbol, interval, chartType, provider, chartLayout);
        });

        // Listen for layout changes
        chartLayout.addEventListener('layout-change', async () => {
          console.log('Layout changed, reloading all panes...');
          await new Promise(resolve => setTimeout(resolve, 100));
          await loadAllPanes(provider, chartLayout);
        });

        // Load initial data for all panes only if config wasn't restored
        // (If config was restored, the config-restored handler already loaded the panes)
        if (!configWasRestored) {
          await loadAllPanes(provider, chartLayout);
        }

        console.log('\n✨ OakView is now connected to VoltTrading backend');
        console.log('Try changing symbols, timeframes, or layouts using the toolbar!');

      } catch (error) {
        console.error('Initialization failed:', error);
        console.log('\n❌ Make sure the VoltTrading backend is running on http://localhost:8000');
      }
    }

    // Load all panes with their respective settings
    async function loadAllPanes(provider, chartLayout) {
      const chartCount = chartLayout.getChartCount();
      console.log(`Loading ${chartCount} pane(s)...`);

      for (let i = 0; i < chartCount; i++) {
        const chart = chartLayout.getChartAt(i);
        if (chart) {
          const paneId = chartLayout.getPaneId(i);
          const settings = chartLayout.getPaneSettings(i);

          // Get symbol, interval, and chart type from saved settings or defaults
          const symbol = settings?.symbol || chart.getAttribute('symbol') || 'AAPL';
          const interval = settings?.interval || '1D';
          const chartType = settings?.chartType || 'candlestick';

          console.log(`[Pane ${i}] Loading with symbol=${symbol}, interval=${interval}, chartType=${chartType}`);
          await loadPane(i, paneId, symbol, interval, chartType, provider, chartLayout);
        }
      }
    }

    // Load a single pane with specific symbol and interval
    async function loadPane(paneIndex, paneId, symbol, interval, chartType, provider, chartLayout) {
      try {
        const chart = chartLayout.getChartAt(paneIndex);
        if (!chart) return;

        // Unsubscribe from previous subscription for this pane
        const existingSub = paneSubscriptions.get(paneId);
        if (existingSub?.unsubscribe) {
          existingSub.unsubscribe();
        }

        // Set chart type before loading data
        if (chartType && chart._currentChartType !== chartType) {
          chart._currentChartType = chartType;
        }

        // Fetch historical data
        const historical = await provider.fetchHistorical(symbol, interval);
        console.log(`[Pane ${paneIndex}] Loaded ${historical.length} bars for ${symbol} @ ${interval}`);

        // Update chart with data (this will trigger updateChartType internally)
        chart.setData(historical);

        // Update legend with current symbol, interval, and exchange
        chart.updateLegend(symbol, interval, 'NASDAQ');

        // Subscribe to real-time updates for this pane only
        const unsubscribe = provider.subscribe(symbol, interval, (bar) => {
          // Make sure chart still exists and matches current subscription
          const currentSub = paneSubscriptions.get(paneId);
          if (currentSub && currentSub.symbol === symbol && currentSub.interval === interval) {
            const currentChart = chartLayout.getChartAt(paneIndex);
            if (currentChart) {
              currentChart.updateRealtime(bar);
            }
          }
        });

        // Store subscription info
        paneSubscriptions.set(paneId, { unsubscribe, symbol, interval });

        console.log(`[Pane ${paneIndex}] Subscribed to ${symbol} @ ${interval}`);
      } catch (error) {
        console.error(`[Pane ${paneIndex}] Error loading chart:`, error);
      }
    }

    // Start
    init();
  </script>
</body>
</html>

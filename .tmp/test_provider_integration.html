<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>VoltTradingProvider Automated Test</title>
  <style>
    body {
      font-family: monospace;
      padding: 20px;
      background: #1a1a1a;
      color: #00ff00;
    }
    .test { margin: 10px 0; }
    .pass { color: #00ff00; }
    .fail { color: #ff0000; }
    .pending { color: #ffaa00; }
  </style>
</head>
<body>
  <h1>VoltTradingProvider Integration Test</h1>
  <div id="results"></div>

  <script type="module">
    import { VoltTradingProvider } from '../src/data-providers/index.js';

    const results = document.getElementById('results');

    function log(message, status = 'pending') {
      const div = document.createElement('div');
      div.className = `test ${status}`;
      const icon = status === 'pass' ? '✓' : status === 'fail' ? '✗' : '⧗';
      div.textContent = `${icon} ${message}`;
      results.appendChild(div);
      console.log(`[${status.toUpperCase()}] ${message}`);
    }

    async function runTests() {
      log('Starting VoltTradingProvider integration tests...');

      // Test 1: Service wrappers
      log('Creating WebSocket and API services...', 'pending');

      class TestWebSocketService {
        constructor() {
          this.connected = false;
          this.listeners = new Map();
        }
        connect() {
          setTimeout(() => {
            this.connected = true;
            this.emit('connected', {});
          }, 100);
        }
        disconnect() { this.connected = false; }
        isConnected() { return this.connected; }
        on(event, callback) {
          if (!this.listeners.has(event)) this.listeners.set(event, []);
          this.listeners.get(event).push(callback);
          return () => {};
        }
        emit(event, data) {
          const listeners = this.listeners.get(event);
          if (listeners) listeners.forEach(cb => cb(data));
        }
      }

      class TestAPIService {
        async getHistoricalData(symbol, duration, timeframe) {
          const response = await fetch(`http://localhost:8000/api/market-data/${symbol}/history?timeframe=${timeframe}&duration=${encodeURIComponent(duration)}`);
          return await response.json();
        }
        async subscribeMarketData(symbols) {
          const response = await fetch('http://localhost:8000/api/market-data/subscribe', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(symbols)
          });
          return await response.json();
        }
        async unsubscribeMarketData(symbols) {
          const response = await fetch('http://localhost:8000/api/market-data/unsubscribe', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(symbols)
          });
          return await response.json();
        }
      }

      const wsService = new TestWebSocketService();
      const apiService = new TestAPIService();
      log('Services created', 'pass');

      // Test 2: Provider initialization
      log('Creating VoltTradingProvider...', 'pending');
      const provider = new VoltTradingProvider({ wsService, apiService });
      log('Provider created', 'pass');

      // Test 3: Initialization
      log('Initializing provider...', 'pending');
      try {
        await provider.initialize();
        log('Provider initialized successfully', 'pass');
      } catch (error) {
        log(`Initialization failed: ${error.message}`, 'fail');
        return;
      }

      // Test 4: Fetch historical data
      log('Fetching historical data for AAPL 1m...', 'pending');
      try {
        const historical = await provider.fetchHistorical('AAPL', '1m');

        if (historical.length === 0) {
          log('No historical data received', 'fail');
        } else {
          log(`Received ${historical.length} bars`, 'pass');

          // Validate data structure
          const bar = historical[0];
          const requiredFields = ['time', 'open', 'high', 'low', 'close'];
          const hasAllFields = requiredFields.every(field => bar[field] !== undefined);

          if (!hasAllFields) {
            log('Bar missing required fields', 'fail');
          } else {
            log('Bar structure valid', 'pass');
          }

          // Validate timestamp is Unix seconds
          const now = Date.now() / 1000;
          if (bar.time > now + 86400 || bar.time < now - 86400 * 365) {
            log(`Timestamp invalid: ${bar.time}`, 'fail');
          } else {
            log(`Timestamp valid: ${bar.time}`, 'pass');
          }

          // Validate OHLC logic
          if (bar.high < bar.low || bar.high < bar.open || bar.high < bar.close ||
              bar.low > bar.open || bar.low > bar.close) {
            log('OHLC logic invalid', 'fail');
          } else {
            log('OHLC logic valid', 'pass');
          }
        }
      } catch (error) {
        log(`Historical fetch failed: ${error.message}`, 'fail');
      }

      // Test 5: Interval conversion
      log('Testing interval conversion...', 'pending');
      const testIntervals = {
        '1s': '1S',
        '1m': '1',
        '5m': '5',
        '1h': '60',
        '1D': '1D'
      };

      let intervalTestsPassed = 0;
      for (const [input, expected] of Object.entries(testIntervals)) {
        const result = provider._convertInterval(input);
        if (result === expected) {
          intervalTestsPassed++;
        } else {
          log(`Interval ${input} → ${result} (expected ${expected})`, 'fail');
        }
      }

      if (intervalTestsPassed === Object.keys(testIntervals).length) {
        log('All interval conversions passed', 'pass');
      }

      // Test 6: Subscription
      log('Testing subscription...', 'pending');
      try {
        let updateCount = 0;
        const unsubscribe = provider.subscribe('AAPL', '1m', (bar) => {
          updateCount++;
          if (updateCount === 1) {
            log('Received first update from subscription', 'pass');

            // Validate update structure
            if (bar.time && bar.open && bar.high && bar.low && bar.close) {
              log('Update structure valid', 'pass');
            } else {
              log('Update structure invalid', 'fail');
            }

            // Cleanup
            setTimeout(() => {
              unsubscribe();
              log('Unsubscribed successfully', 'pass');

              // Final summary
              log('═'.repeat(60));
              log('TEST SUITE COMPLETE', 'pass');
              log('Check results above for any failures');
            }, 1000);
          }
        });

        log('Subscribed to real-time updates', 'pass');

      } catch (error) {
        log(`Subscription failed: ${error.message}`, 'fail');
      }
    }

    // Run tests when page loads
    runTests().catch(error => {
      log(`Test suite error: ${error.message}`, 'fail');
      console.error(error);
    });
  </script>
</body>
</html>
